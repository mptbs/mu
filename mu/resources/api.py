"""
Contains definitions for the MicroPython micro:bit related APIs so they can be
used in the editor for autocomplete and call tips.

Copyright (c) 2015-2016 Nicholas H.Tollervey and others (see the AUTHORS file).

Based upon work done for Puppy IDE by Dan Pope, Nicholas Tollervey and Damien
George.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

TBSENSE_APIS = [
    #machine.I2C
    "machine.I2C(id, *, scl, sda, freq=400000, timeout=5000) \nConstruct and return a new I2C object.\n'id' identifies the particular I2C peripheral.\n'scl' should be a pin object or a string identifying the pin to use for SCL.\n'sda' should be a pin object or a string identifying the pin to use for SDA.\n'freq' should be an integer that sets the maximum transmission frequency (baudrate).\n'timeout' should be an integer specifying how many milliseconds to wait before timing out if a device is not responding.",
    "machine.I2C.init(*, scl, sda, freq=400000, timeout=5000) \nInitialize the I2C peripheral.\n'scl' should be a pin object or a string identifying the pin to use for SCL.\n'sda' should be a pin object or a string identifying the pin to use for SDA.\n'freq' should be an integer that sets the maximum transmission frequency (baudrate).\n'timeout' should be an integer specifying how many milliseconds to wait before timing out if a device is not responding.",
    "I2C.scan() \nScan all I2C addresses from 0x08 to 0x7f and return a list of those that respond.",
    "machine.I2C.readfrom(addr, nbytes, stop=True)\n Read data from an I2C-device. Returns a bytes object with the data read.\n 'addr' is the address to read from.\n 'nbytes' is the number of bytes to read\n 'stop' whether to generate a STOP condition at the end of transfer.\n",
    "machine.I2C.readfrom_into(addr, buf, stop=True)\nRead data from an I2C-device into a preallocated buffer. Allow the use of the I2C-bus from an interrupt routine.\n'addr' is the address to read from.\n'buf' is a buffer to read into. The length of the buffer determines how many bytes to read.\n'stop' whether to generate a STOP condition at the end of transfer.\n",
    "machine.I2C.writeto(addr, buf, stop=True)\n Write data to an I2C-device and returns the number of ACKs received. This function can be used from an interrupt routine.\n 'addr' is the address to write to.\n 'buf' can be an integer or buffer to write.\n 'stop' whether to generate a STOP condition at the end of transfer.\n",
    "machine.I2C.readfrom_mem(addr, memaddr, nbytes, \*, addrsize=8)\n Read data from an address on an I2C-device. Returns a 'bytes' object with the data read.\n'addr' is the address of the I2C-device.\n'memaddr' is the memory address to read from on the I2C-device.\n'nbytes' is the number of bytes to read.\n'addrsize' is the size of 'memaddr', either 8 or 16 bits.\n",
    "machine.I2C.readfrom_mem_into(addr, memaddr, buf, \*, addrsize=8)\n Read data from an address on an I2C-device into a preallocated buffer. Returns the number of bytes read. This function can be used from an interrupt routine.\n'addr' is the address of the I2C-device.\n'memaddr' is the memory address to read from on the I2C-device.\n'buf' is a buffer to read into. The length of the buffer determines how many bytes to read.\n'addrsize' is the size of 'memaddr', either 8 or 16 bits.\n",
    "machine.I2C.writeto_mem(addr, memaddr, buf, \*, addrsize=8)\nWrite data to an address on an I2C-device. Returns the number of bytes written. This function can be used from an interrupt routine.\n'addr' is the address of the I2C-device.\n'memaddr' is the memory address to read from on the I2C-device.\n'buf' can be an integer or buffer to write.\n'addrsize' is the size of 'memaddr', either 8 or 16 bits.\n",
#machine.Pin
    "machine.Pin( id, ... ) \nCreate a new Pin object associated with id.\nIf additional arguments are given, they are used to initialise the pin( see 'Pin.init' ).\nIf the pin has been instantiated before, the previously instantiated object will be returned.",
    "machine.Pin.set_port_config( port, port_config, input_disable, slewrate, drive_strength )\nThis function sets the port config for 'port_config'. The arguments are:\n''port'' is the port to set the config for. It can either be a character\nor a number denoting the port, where port A = 0.\n'port_config' which 'port_config' to configure. Can be\nan integer between 0 and 1.\n'input_disable' is a boolean value. If 'True' then inputs are\ndisabled for this port.\n'slewrate' is the slewrate. It can be an integer between 0 and 7,\nwhere 7 gives the fastest slewrate.\n'drive_strength' is the drive strength. The possible values are:\n'Pin.DRIVE_STRENGTH_HIGH' which equates to 10mA.\n'Pin.DRIVE_STRENGTH_LOW' which equates to 1mA.\n",
    "machine.Pin.init( mode, pull, \*, filter=False, port_config = 0 )\nInitialize the pin. The arguments are:\n'mode' which selects the mode of the pin. The possible values are:\n'Pin.DISABLED' - pin is disabled\n'Pin.IN' - input pin\n'Pin.OUT' - output pin\n'Pin.OPEN_DRAIN' - open-drain mode, also called wired-and mode.\n'Pin.OPEN_SOURCE' - open-source mode, also called wired-or mode.\n'pull' which selects the pull direction. Possible values are:\n'Pin.PULL_UP' - pull-up resistor. Only applicable when mode is 'Pin.IN' or 'Pin.OPEN_DRAIN'\n'Pin.PULL_DOWN' - pull-down resistor. Only applicable when mode is 'Pin.IN' or 'Pin.OPEN_SOURCE'.\n'Pin.PULL_NONE' - no pull resistor.\n'filter' Selects whether the pin has the glitch suppression filter enabled or not. This accepts a boolean value. Only applicable if 'mode' is 'Pin.IN' or 'Pin.OPEN_DRAIN'.:\n'port_config' - which port config is used by this pin. Can be an integer between 0 and 1.",
    "machine.Pin.__call__( [value] )\nGet or set the digital logic level of the pin:\nWith no argument, return 0 or 1 depending on the logic level of the pin.\nWith 'value' given, sets the output of the pin if the mode is Pin.OUT,\nPin.OPEN_DRAIN or Pin.OPEN_SOURCE, otherwise does nothing. If 'value'\nconverts to boolean 'True' the pin is set high, otherwise it is set\nlow.\n",
    "machine.Pin.value( [value] )\nIdentical to 'Pin.__call__'.",
    "machine.Pin.toggle()\nToggles the pin output if it is set to an output mode, either 'Pin.OUT', 'Pin.OPEN_DRAIN', or 'Pin.OPEN_SOURCE'.",
    "machine.Pin.id()\nGet the pin id.",
    "machine.Pin.pin()\nGet the pin number",
    "machine.Pin.port()\nGet the port.",
    "machine.Pin.mode( [mode] )\nSet or get the pin mode." ,
    "machine.Pin.pull( [pull] )\nSet or get the pin pull direction.",
    "machine.Pin.filter( [filter] )\nGet or set whether the filter is enabled or not.",
    "machine.Pin.port_config( [port_config] )\nGet or set the port config used for this pin.",
    "machine.Pin.irq( \*, trigger, int_no = pin_no, priority=7, handler )\nInitialize an interrupt that is triggered when the pin input level is changed.\n'trigger' configures which edge generates an interrupt. Possible values are:\n'Pin.IRQ_FALLING' for interrupt on a falling edge.\n'Pin.IRQ_RISING' for an interrupt on a rising edge.\nThe values can be *ORed* together, for instancetrigger = Pin.IRQ_FALLING | Pin.IRQ_RISING.\n'int_no' specifies which interrupt number is used for this pin interrupt. Note that two pins cannot share the same interrupt number. The value defaults to the cpu pin number.\n'priority' level of the interrupt. Can be in the range of 1-7, where a higher value represents a higher priority.\n'handler' which is an optional callback when the interrupt occurs.\nThe callback should be of the form 'def cb( pin_obj )'. This function returns an 'irq-object <machine.irq>'.\nIf no arguments are given, the pin interrupt configuration is left as is.\n This function provides a useful method of getting the irq-object inside the interrupt handler.",
    "machine.Pin.board",
    "machine.Pin.mcu",
    "machine.Pin.DISABLED",
    "machine.Pin.IN",
    "machine.Pin.OUT",
    "machine.Pin.OPEN_DRAIN",
    "machine.Pin.OPEN_SOURCE",
    "machine.Pin.PULL_UP",
    "machine.Pin.PULL_DOWN",
    "machine.Pin.PULL_NONE",
    "machine.Pin.DRIVE_STRENGTH_HIGH",
    "machine.Pin.DRIVE_STRENGTH_LOW",
    "machine.Pin.IRQ_FALLING",
    "machine.Pin.IRQ_RISING",
#tbsense.AirQuality
    "tbsense.AirQuality(...)\nConstruct an AirQuality object in order to access the Indoor Air Quality \nsensor. The extra arguments given are used for initialization and are \nidentical to 'AirQuality.init'. If no arguments are given, \nthe sensor stays in the same state as last initialization.",
    "tbsense.AirQuality.init(mode, '*', temperature, relative_humidity)\nInitialize the Air Quality sensor with 'mode' one of the following\n- 'AirQuality.MODE_IDLE' to disable measurements\n- 'AirQuality.MODE_INTERVAL_1' to perform a measurement once every second.\n- 'AirQuality.MODE_INTERVAL_10' to perform a measurement every 10th second.\n- 'AirQuality.MODE_INTERVAL_60' to perform a measurement every 60th second.\nThe arguments 'temperature' and 'relative_humidity' are optional, and \nare used to calibrate the sensor. The class 'RHTemp'\ncan be used to obtain these measurements.",
    "tbsense.AirQuality.deinit()\nTurn off the sensor",
    "tbsense.AirQuality.new_data()\nReturns true if new data is available.",
    "tbsense.AirQuality.tvoc()\nReturns ppb of total volatile organic compounds.",
    "tbsense.AirQuality.eco2()\nReturns ppm of equivalent CO2 level.",
    "tbsense.AirQuality.mode([mode])\nSet or get the mode of the sensor",
    "tbsense.AirQuality.calibrate(temperature, relative_humidity)\nCalibrate the Air Quality measurement using temperature and relative humidity data.",
    "tbsense.AirQuality.MODE_IDLE",
    "tbsense.AirQuality.MODE_INTERVAL_1",
    "tbsense.AirQuality.MODE_INTERVAL_10",
    "tbsense.AirQuality.MODE_INTERVAL_60",
#tbsense.Hall
    "tbsense.Hall(...)\nConstruct a Hall object to access the Hall-effect sensor.\n The extra arguments given are used for initialization and are identical to 'Hall.init'.\n If no extra arguments are given, the sensor stays in the same state as the last initialization.",
    "tbsense.Hall.init(mode, '*', threshold=16, hysteresis=0,polarity=Hall.OMNI, output_invert=false, scale=Hall.20mT, sampling_period=0)\nThis function initializes the Hall sensor. The parameter 'mode' can be one of two values:\n- 'Hall.THRESHOLD' to use the Hall sensor in threshold mode. The sensor can then be used as a magnetic switch, with optional callback. Interrupts need to be enabled for this mode to work.\n- 'Hall.MEASURE' to use the Hall sensor in measure mode. The sensor will then sample the magnetic field with a given sampling period. This can for example be used to measure the distance to an object with a known magnetic field.\nIf 'mode' is 'Hall.THRESHOLD', one Pin-object will be used for interrupts. The following parameters are available:\n- 'threshold' which sets the magnetic field strength to activate at. This is given in mT.\n- 'hysteresis' the hysteresis around 'threshold' at which to activate/deactivate. This is given in mT.\n- 'polarity' sets the polarity which to activate at. Can be one of the following:\n\n- 'Hall.OMNI' to activate when the absolute value of the magnetic field exceedes 'threshold'\n- 'Hall.POSITIVE' to activate when the value of the magnetic field exceedes 'threshold'\n- 'Hall.NEGATIVE' to activate when the negated value of the magnetic field exceedes 'threshold'. \n- 'output_invert' should be set so the interrupt pin will mostly remain high, this is to converve power. If the field strength will mostly exceed 'threshold' this should be 'false', otherwise 'true'.\nIf 'mode' is 'Hall.MEASURE', the following parameters are available:\n- 'scale' which sets the scale to operate at. It can be one of the following two parameters:\n- 'Hall.MT20' - the maximum measurable field strength is ±20.47 mT with a resolution of 0.00125 mT.\n- 'Hall.MT200' - the maximum measurable field strengh is ±204.7 mT with a resolution of 0.0125 mT.\n- 'sampling_period' - this is the time period in microseconds between samples. It can be a value between 11 and 172000 microseconds (0.172 seconds). If set to 0, samples are updated continously. In order to save power, this value should be as high as possible.",
    "tbsense.Hall.deinit()\nDeinitializes the UV-sensor and frees interrupt pin if 'mode' was in 'Hall.THRESHOLD'." ,
    "tbsense.Hall.mode()\nReturns the current mode. Use init if you wish to reconfigure the Hall effect sensor.",
    "tbsense.Hall.active()\nReturns 'true' if 'mode' is 'Hall.THRESHOLD' and 'threshold' is exceeded. Returns false otherwise.",
    "tbsense.Hall.callback([func])\nGet the callback function if no argument is given. Set the callback-function if an argument is given.\n The 'func' callback function is passed 1 argument. The argument is 'true' if threshold is exceeded, 'false' if not.\n If passed 'None', the interrupts are turned off.",
    "tbsense.Hall.measure()\nReturns the last sampled magnetic field strength from the sensor.\nIf 'mode' is 'Hall.THRESHOLD' this function returns 'None'." ,
    "tbsense.Hall.THRESHOLD",
    "tbsense.Hall.MEASURE",
    "tbsense.Hall.OMNI",
    "tbsense.Hall.POSITIVE",
    "tbsense.Hall.NEGATIVE",
    "tbsense.Hall.MT20",
    "tbsense.Hall.MT200",
#tbsense.IMU
    "tbsense.IMU(...)\nConstruct an IMU object. The extra arguments are used for initialization,\n the parameters can be found in 'IMU.init'.\n If no extra arguments are given, the settings from the last initialization is used.",
    "tbsense.IMU.init(sample_rate = 0, accel_scale = IMU.ACCEL_SCALE_2G, accel_bw = IMU.ACCEL_BW_50HZ, gyro_scale = IMU.GYRO_SCALE_250DPS, gyro_bw = IMU.GYRO_BW_12HZ)\nConfigure IMU and also perform a calibration. The sample rate is set as close as possible to 'sample_rate'.",
    "tbsense.IMU.deinit()\nResets and turns off the IMU.",
    "tbsense.IMU.callback_on_measurement([callback, gyro_data, accel_data])\nGet a callback on every new measurement. If 'gyro_data' or 'accel_data' are passed, the data from the IMU will be put here. 'gyro_data' and 'accel_data' has to be of type array.array with a length of at least 3 and typecode 'f'.\n Signature of a callback is 'def cb()'",
    "tbsense.IMU.wake_on_motion(threshold, [callback])\nGo to sleep, wake up when accelerometer value exceeds 'threshold'.\n If callback is passed, the function returns and instead of sleeping, a callback will be called on interrupt.\n 'threshold' is a floating point value between 0.0g and 1.0g where 1g is equal to an acceleration of 9.81m/s^2.\n Signature of a callback is 'def cb()'",
    "tbsense.IMU.wake_on_motion(threshold)\nMakes the system sleep until the change in absolute accelerometer value exceedes 'threshold' relative to the absolute value from when the function was called.",
    "tbsense.IMU.accel_measurement()\nReturn a measurement with accelerometer data. Data is returned as a tuple.",
    "tbsense.IMU.gyro_measurement()\nReturn a measurement with gyroscope data. Data is returned as a tuple.",
    "tbsense.IMU.temperature()\nReturn a temperature measurement from the IMU.",
    "tbsense.IMU.calibrate()\nCalibrate the IMU.",
    "tbsense.IMU.sleep(enable)\nIf 'enable' is 'True' the IMU goes to sleep, otherwise the IMU wakes up.",
    "tbsense.IMU.accel_scale([accel_scale])\nSet or get the accelerometer scale of the IMU. See section 'Constants' for values.",
    "tbsense.IMU.accel_bw([accel_bw])\nSet or get the accelerometer bandwidth. See section 'Constants' for values.",
    "tbsense.IMU.gyro_scale([gyro_scale])\nSet or get the gyroscope scale. See section 'Constants' for values.",
    "tbsense.IMU.gyro_bw([gyro_bw])\nSet or get the gyroscope bandwidth. See section 'Constants' for values.",
    "tbsense.IMU.sample_rate([sample_rate])\nSet or get the sample rate. The sample rate is set as closely as possible to 'sample_rate'.",
    "tbsense.IMU.ACCEL_SCALE_2G",
    "tbsense.IMU.ACCEL_SCALE_4G",
    "tbsense.IMU.ACCEL_SCALE_8G",
    "tbsense.IMU.ACCEL_SCALE_16G",
    "tbsense.IMU.ACCEL_BW_6HZ",
    "tbsense.IMU.ACCEL_BW_12HZ",
    "tbsense.IMU.ACCEL_BW_24HZ",
    "tbsense.IMU.ACCEL_BW_50HZ",
    "tbsense.IMU.ACCEL_BW_111HZ",
    "tbsense.IMU.ACCEL_BW_246HZ",
    "tbsense.IMU.ACCEL_BW_470HZ",
    "tbsense.IMU.ACCEL_BW_1210HZ",
    "tbsense.IMU.GYRO_SCALE_250DPS",
    "tbsense.IMU.GYRO_SCALE_500DPS",
    "tbsense.IMU.GYRO_SCALE_1000DPS",
    "tbsense.IMU.GYRO_SCALE_2000DPS",
    "tbsense.IMU.GYRO_BW_6HZ",
    "tbsense.IMU.GYRO_BW_12HZ",
    "tbsense.IMU.GYRO_BW_24HZ",
    "tbsense.IMU.GYRO_BW_51HZ",
    "tbsense.IMU.GYRO_BW_120HZ",
    "tbsense.IMU.GYRO_BW_150HZ",
    "tbsense.IMU.GYRO_BW_200HZ",
    "tbsense.IMU.GYRO_BW_360HZ",
    "tbsense.IMU.GYRO_BW_12100HZ",
#tbsense.LED
    "tbsense.LED(led)\nReturn one of the two singleton objects for controlling an LED. The argument led can be either\n 'LED.GREEN' - To control the green LED. Can also be referenced by the integer 0.\n 'LED.RED' - To control the red LED. Can also be referenced by the integer 1.\n",
    "tbsense.LED.off()\nTurn off the LEDs.",
    "tbsense.LED.on()\nTurn on the LEDs." ,
    "tbsense.LED.toggle()\nIf the LEDs are turned on, 'LED.off' is called. If the LEDs are turned off, 'LED.on' is called." ,
    "tbsense.LED.GREEN",
    "tbsense.LED.RED",
#tbsense.Mic
    "tbsense.Mic()\nConstruct a Mic object in order to access the microphone.\n The object returned is a singleton, which means that the same object is returned when this function is called.",
    "tbsense.Mic.sound_level(fs=32768, samples=128)\nReturns the sound level in decibel.\n 'fs' is the sampling frequency and 'samples' is the number of samples to base the measurement on.\n'samples' can maximum be 2048.\nThis function uses approximately 'samples'/'fs' seconds to return.",
    "tbsense.Mic.sample(fs=32768, samples=128)\nReturns 'samples' number of samples, sampled at sampling frequency 'fs'.\nThe result is returned as a list.\n'samples' can maximum be 2048.\nThis function uses approximately 'samples'/'fs' seconds to return.",
#tbsense.Pressure
    "tbsense.Pressure(...)\nConstruct a Pressure object.\n The arguments given are used for initialization and are equal to 'Pressure.init'.\n If no extra arguments are given, the settings from the last initialization is retained." ,
    "tbsense.Pressure.init(mode=4)\nInitialize and enable the Pressure sensor.\n 'mode' can be a value between 0 and 4, where 0 is low power usage/low accuracy and 4 is high power usage/high accuracy.",
    "tbsense.Pressure.deinit()\nDeinit the pressure sensor." ,
    "tbsense.Pressure.mode([mode])\nSet or get the mode of the pressure sensor.\n If no arguments are given, the mode is returned. If an argument is given, the mode is set.\n Valid values for 'mode' is between 0 and 4. 0 is low power usage/low accuracy, while 4 is high power usage/high accuracy",
    "tbsense.Pressure.pressure()\nReturn a new measurement from the pressure sensor.\n The result is returned in Pascals.\n A new measurement takes 7 ms when 'mode' is 0, and up to 45 ms when 'mode' is 4. \n",
    "tbsense.Pressure.temperature()\nReturn a new measurement from the onboard thermometer of the pressure sensor.\n The result is returned in Celcius.\n A new measurement takes 7 ms when 'mode' is 0, and up to 45 ms when 'mode' is 4." ,
#tbsense.RGBLED
    "tbsense.RGBLED(active=RGBLED.LED_ALL)\nReturns the RGBLED singleton. The argument 'active' can be a binary or combination of the following:\n- 'RGBLED.LED_NONE' - To disable all LEDs\n- 'RGBLED.LED0' - To enable LED 0\n- 'RGBLED.LED1' - To enable LED 1\n- 'RGBLED.LED2' - To enable LED 2\n- 'RGBLED.LED3' - To enable LED 3\n- 'RGBLED.LED_TOP' - To enable LED on top side of board. Is equal to 'RGBLED.LED2 | RGBLED.LED3'\n- 'RGBLED.LED_BOTTOM' - To enable LEDs on bottom side of board. Is equal to 'RGBLED.LED0 | RGBLED.LED1'\n- 'RGBLED.LED_ALL' - To enable all the RGB LEDs on the board.",
    "tbsense.RGBLED.off()\nTurn off the LEDs",
    "tbsense.RGBLED.on()\nTurn on the LEDs.\nThey are either set to the last specified color, or if no color has ben specified they are set to full color.",
    "tbsense.RGBLED.color([red, green, blue])\nIf no arguments are given, a tuple with the current color configuration is returned.\n If the three arguments are given, the RGB LEDs are set to that color.\n The values of 'red', 'green' and 'blue' has to be a value between 0 and 255.\n When either 'red', 'green' or 'blue' is a value different than 0 or 255, TIMER0's PWM is used to implement it.\n Utilizing TIMER0 in any other way at the same time will conflict with the PWM functionality.",
    "tbsense.RGBLED.toggle()\nIf the RGB LEDs are turned on, 'RGBLED.off' is called. If the RGB LEDs are turned off, 'RGBLED.on' is called.",
    "tbsense.RGBLED.active([active])\nSet which RGB LEDs that are active.\n If no arguments are given, return currently active LEDs.\n The argument 'active' can be a binary or combination of the following:\n- 'RGBLED.LED_NONE' - To disable all LEDs\n- 'RGBLED.LED0' - To enable LED 0\n- 'RGBLED.LED1' - To enable LED 1\n- 'RGBLED.LED2' - To enable LED 2\n- 'RGBLED.LED3' - To enable LED 3\n- 'RGBLED.LED_TOP' - To enable LED on top side of board. Is equal to 'RGBLED.LED2 | RGBLED.LED3'\n- 'RGBLED.LED_BOTTOM' - To enable LEDs on bottom side of board. Is equal to 'RGBLED.LED0 | RGBLED.LED1'\n- 'RGBLED.LED_ALL' - To enable all the RGB LEDs on the board.",
    "tbsense.RGBLED.LED_NONE",
    "tbsense.RGBLED.LED0",
    "tbsense.RGBLED.LED1",
    "tbsense.RGBLED.LED2",
    "tbsense.RGBLED.LED3",
    "tbsense.RGBLED.LED_TOP",
    "tbsense.RGBLED.LED_BOTTOM",
    "tbsense.RGBLED.LED_ALL",
#tbsense.RHTemp
    "tbsense.RHTemp( )\nConstruct an RHTemp object.",
    "tbsense.RHTemp.init()\nInitialize and enable the Relative Humidity and Temperature sensor.",
    "tbsense.RHTemp.deinit()\nDeinitialize the Relative Humidity and Temperature sensor." ,
    "tbsense.RHTemp.relative_humidity()\nReturn a new relative humidity measurement from the sensor. The result is returned in RH%.",
    "tbsense.RHTemp.temperature()\nReturn a new temperature measurement from the sensor. The result is returned in Celcius.",
#tbsense.Button
    "tbsense.Button( )\nConstruct a Button object.",
    "tbsense.Button.is_pressed()\nReturn True/False depending on the button state.",
#tbsense
    "tbsense.reset_module()\nTurn off power to all sensors on the board, including the RGB LEDs.",
    "tbsense.reinit_peripherals()\nReinitialize I2C0 and SPI0 (USART0) to a configuration suitable for using the sensors on the board.",
    "tbsense.delay(ms)\nDelay for the given number of milliseconds.",
    "tbsense.ms()\nReturn the number of milliseconds since the last board reset.\nThe returned result is a micropython smallint (31-bit signed number),\nso after 2^30 milliseconds (12.4 days) this number will become negative.",
    "tbsense.ms_elapsed(start)\nReturn the number of milliseconds since 'start'.\nThis function takes care of counter wrap and can be used to measure periods of up to 12.4 days.",
    "tbsense.tbsense.UV()\nConstruct a UV object.",
    "tbsense.UV.init()\nInitialize and enable the UV sensor.",
    "tbsense.UV.deinit()\nDeinit the pressure sensor.",
    "tbsense.UV.uv_index()\nReturn a new measurement of the UV Index from the sensor. The result is returned as an UV index.",
    "tbsense.UV.amb_light()\nReturn a new measurement of the Ambient light from the sensor. The result is returned in Lux."
]
# Based upon the help text found in source/microbit/help.c in the
# microbit-micropython repos.
MICROPYTHON_APIS = [
# # System state objects.
# "microbit.panic() \nPut micro:bit in panic() mode and display an unhappy face.\nPress the reset button to exit panic() mode.",
    # "microbit.sleep(time) \nPut micro:bit to sleep for some milliseconds (1 second = 1000 ms) of time.\nsleep(2000) gives micro:bit a 2 second nap.",
    # "microbit.running_time() \nReturn running_time() in milliseconds since micro:bit's last reset.",
    # "microbit.temperature() \nReturn micro:bit's temperature in degrees Celcius.",
    # # Accelerometer 3D orientation
    # "microbit.accelerometer.get_x() \nReturn micro:bit's tilt (X acceleration) in milli-g's.",
    # "microbit.accelerometer.get_y() \nReturn micro:bit's tilt (Y acceleration) in milli-g's.",
    # "microbit.accelerometer.get_z() \nReturn micro:bit's up-down motion (Z acceleration) in milli-g's.\nZ is a positive number when moving up. Moving down, Z is a negative number.",
    # "microbit.accelerometer.is_gesture(name) \nReturn True or False to indicate if the named gesture is currently active.\nMicroPython understands the following gestures: 'up', 'down', 'left', 'right',\n'face up', 'face down', 'freefall', '3g', '6g', '8g' and 'shake'.",
    # "microbit.accelerometer.was_gesture(name) \nReturn True or False to indicate if the named gesture was active since the\nlast call.\nMicroPython understands the following gestures: 'up', 'down', 'left', 'right',\n'face up', 'face down', 'freefall', '3g', '6g', '8g' and 'shake'.",
    # "microbit.accelerometer.get_gestures() \nReturn a list indicating the gesture history. The most recent gesture is last.\nCalling this method also clears the gesture history.\nMicroPython understands the following gestures: 'up', 'down', 'left', 'right',\n'face up', 'face down', 'freefall', '3g', '6g', '8g' and 'shake'.",
    # # Pushbutton
    # "microbit.button_a.is_pressed() \nIf button A is pressed down, is_pressed() is True, else False.",
    # "microbit.button_a.was_pressed() \nUse was_pressed() to learn if button A was pressed since the last time\nwas_pressed() was called. Returns True or False.",
    # "microbit.button_a.get_presses() \nUse get_presses() to get the running total of button presses, and also\nreset this counter to zero.",
    # "microbit.button_b.is_pressed() \nIf button B is pressed down, is_pressed() is True, else False.",
    # "microbit.button_b.was_pressed() \nUse was_pressed() to learn if button B was pressed since the last time\nwas_pressed() was called. Returns True or False.",
    # "microbit.button_b.get_presses() \nUse get_presses() to get the running total of button presses, and also\nreset this counter to zero.",
    # # Compass 3D direction heading
    # "microbit.compass.is_calibrated() \nIf micro:bit's compass is_calibrated() and adjusted for accuracy, return True.\nIf compass hasn't been adjusted for accuracy, return False.",
    # "microbit.compass.calibrate() \nIf micro:bit is confused, calibrate() the compass to adjust the its accuracy.\nWill ask you to rotate the device to draw a circle on the display. Afterwards, micro:bit will know which way is north.",
    # "microbit.compass.clear_calibration() \nReset micro:bit's compass using clear_calibration() command.\nRun calibrate() to improve accuracy.",
    # "microbit.compass.get_x() \nReturn magnetic field detected along micro:bit's X axis.\nUsually, the compass returns the earth's magnetic field in micro-Tesla units.\nUnless...a strong magnet is nearby!",
    # "microbit.compass.get_y() \nReturn magnetic field detected along micro:bit's Y axis.\nUsually, the compass returns the earth's magnetic field in micro-Tesla units.\nUnless...a strong magnet is nearby!",
    # "microbit.compass.get_z() \nReturn magnetic field detected along micro:bit's Z axis.\nUsually, the compass returns the earth's magnetic field in micro-Tesla units.\nUnless...a strong magnet is nearby!",
    # "microbit.compass.get_field_strength() \nReturn strength of magnetic field around micro:bit.",
    # "microbit.compass.heading() \nReturn a number between 0-360 indicating the device's heading. 0 is north.",
    # # Display 5x5 LED grid
    # "microbit.display.show(x, delay=400, wait=True, loop=False, clear=False) \nUse show(x) to print the string or image 'x' to the display. If 'x' is a list\nof images they will be animated together.\nUse 'delay' to specify the speed of frame changes in milliseconds.\nIf wait is False animation will happen in the background while the program continues.\nIf loop is True the animation will repeat forever.\nIf clear is True the display will clear at the end of the animation.",
    # "microbit.display.scroll(string, delay=150, wait=True, loop=False, monospace=False) \nUse scroll(string) to scroll the string across the display.\nUse delay to control how fast the text scrolls.\nIf wait is False the text will scroll in the background while the program continues.\nIf loop is True the text will repeat forever.\nIf monospace is True the characters will always take up 5 pixel-columns.",
    # "microbit.display.clear() \nUse clear() to clear micro:bit's display.",
    # "microbit.display.get_pixel(x, y) \nUse get_pixel(x, y) to return the display's brightness at LED pixel (x,y).\nBrightness can be from 0 (LED is off) to 9 (maximum LED brightness).",
    # "microbit.display.set_pixel(x, y, b) \nUse set_pixel(x, y, b) to set the display at LED pixel (x,y) to brightness 'b'\nwhich can be set between 0 (off) to 9 (full brightness).",
    # "microbit.display.on() \nUse on() to turn on the display.",
    # "microbit.display.off() \nUse off() to turn off the display.",
    # "microbit.display.is_on() \nUse is_on() to query if the micro:bit's display is on (True) or off (False).",
    # # Pins
    # "microbit.pin0.is_touched() \nIf pin0 is_touched() on micro:bit, return True. If nothing is touching the\npin, return False.",
    # "microbit.pin0.read_digital() \nread_digital() value from pin0. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin0.write_digital(value) \nSet pin0 to output high if value is 1, or to low, it it is 0.",
    # "microbit.pin0.read_analog() \nRead the voltage applied to pin0. Return the reading as a number between\n0 (meaning 0v) and 1023 (meaning 3.3v).",
    # "microbit.pin0.write_analog(value) \nSet pin0 to output a value between 0 and 1023.",
    # "microbit.pin0.set_analog_period(period) \nSet the period of the PWM signal output to period milliseconds.",

    # "microbit.pin1.is_touched() \nIf pin1 is_touched() on micro:bit, return True. If nothing is touching the\npin, return False.",
    # "microbit.pin1.read_digital() \nread_digital() value from pin1. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin1.write_digital(value) \nSet pin1 to output high if value is 1, or to low, it it is 0.",
    # "microbit.pin1.read_analog() \nRead the voltage applied to pin1. Return the reading as a number between\n0 (meaning 0v) and 1023 (meaning 3.3v).",
    # "microbit.pin1.write_analog(value) \nSet pin1 to output a value between 0 and 1023.",
    # "microbit.pin1.set_analog_period(period) \nSet the period of the PWM signal output to period milliseconds.",
    # "microbit.pin1.set_analog_period_microseconds(period) \nSet the period of the PWM signal output to period microseconds.",

    # "microbit.pin2.is_touched() \nIf pin2 is_touched() on micro:bit, return True. If nothing is touching the\npin, return False.",
    # "microbit.pin2.read_digital() \nread_digital() value from pin2. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin2.write_digital(value) \nSet pin2 to output high if value is 1, or to low, it it is 0.",
    # "microbit.pin2.read_analog() \nRead the voltage applied to pin2. Return the reading as a number between\n0 (meaning 0v) and 1023 (meaning 3.3v).",
    # "microbit.pin2.write_analog(value) \nSet pin2 to output a value between 0 and 1023.",
    # "microbit.pin2.set_analog_period(period) \nSet the period of the PWM signal output to period milliseconds.",
    # "microbit.pin2.set_analog_period_microseconds(period) \nSet the period of the PWM signal output to period microseconds.",

    # "microbit.pin3.read_digital() \nread_digital() value from pin3. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin2.write_digital(value) \nSet pin3 to output high if value is 1, or to low, it it is 0.",
    # "microbit.pin3.read_analog() \nRead the voltage applied to pin3. Return the reading as a number between\n0 (meaning 0v) and 1023 (meaning 3.3v).",
    # "microbit.pin3.write_analog(value) \nSet pin3 to output a value between 0 and 1023.",
    # "microbit.pin3.set_analog_period(period) \nSet the period of the PWM signal output to period milliseconds.",
    # "microbit.pin3.set_analog_period_microseconds(period) \nSet the period of the PWM signal output to period microseconds.",

    # "microbit.pin4.read_digital() \nread_digital() value from pin4. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin4.write_digital(value) \nSet pin4 to output high if value is 1, or to low, it it is 0.",
    # "microbit.pin4.read_analog() \nRead the voltage applied to pin4. Return the reading as a number between\n0 (meaning 0v) and 1023 (meaning 3.3v).",
    # "microbit.pin4.write_analog(value) \nSet pin4 to output a value between 0 and 1023.",
    # "microbit.pin4.set_analog_period(period) \nSet the period of the PWM signal output to period milliseconds.",
    # "microbit.pin4.set_analog_period_microseconds(period) \nSet the period of the PWM signal output to period microseconds.",

    # "microbit.pin5.read_digital() \nread_digital() value from pin5. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin5.write_digital(value) \nSet pin5 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin6.read_digital() \nread_digital() value from pin6. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin6.write_digital(value) \nSet pin6 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin7.read_digital() \nread_digital() value from pin7. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin7.write_digital(value) \nSet pin7 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin8.read_digital() \nread_digital() value from pin8. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin8.write_digital(value) \nSet pin8 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin9.read_digital() \nread_digital() value from pin9. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin9.write_digital(value) \nSet pin9 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin10.read_digital() \nread_digital() value from pin10. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin10.write_digital(value) \nSet pin10 to output high if value is 1, or to low, it it is 0.",
    # "microbit.pin10.read_analog() \nRead the voltage applied to pin10. Return the reading as a number between\n0 (meaning 0v) and 1023 (meaning 3.3v).",
    # "microbit.pin10.write_analog(value) \nSet pin10 to output a value between 0 and 1023.",
    # "microbit.pin10.set_analog_period(period) \nSet the period of the PWM signal output to period milliseconds.",
    # "microbit.pin10.set_analog_period_microseconds(period) \nSet the period of the PWM signal output to period microseconds.",

    # "microbit.pin11.read_digital() \nread_digital() value from pin11. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin11.write_digital(value) \nSet pin11 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin12.read_digital() \nread_digital() value from pin12. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin12.write_digital(value) \nSet pin12 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin13.read_digital() \nread_digital() value from pin13. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin13.write_digital(value) \nSet pin13 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin14.read_digital() \nread_digital() value from pin14. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin14.write_digital(value) \nSet pin14 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin15.read_digital() \nread_digital() value from pin15. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin15.write_digital(value) \nSet pin15 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin16.read_digital() \nread_digital() value from pin16. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin16.write_digital(value) \nSet pin16 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin19.read_digital() \nread_digital() value from pin19. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin19.write_digital(value) \nSet pin19 to output high if value is 1, or to low, it it is 0.",

    # "microbit.pin20.read_digital() \nread_digital() value from pin20. The reading will be either 0 (lo) or 1 (hi).",
    # "microbit.pin20.write_digital(value) \nSet pin20 to output high if value is 1, or to low, it it is 0.",
    # # I2C
    # "microbit.i2c.read(address, n, repeat=False) \nUse read(address, n) to read 'n' bytes from the device with the 7-bit address.\nIf repeat is True, no stop bit will be sent.",
    # "microbit.i2c.write(adress, buffer, repeat=False) \nUse write(address, buffer) to write to the 'buffer' of the device at the 7-bit 'address'.\nIf repeat is True, no stop bit will be sent.",
    # # Image
    # "microbit.Image(string) \nCreate and use built-in IMAGES to show on the display. Use:\nImage(\n  '09090:'\n  '99999:'\n  '99999:'\n  '09990:'\n  '00900:')\n...to make a new 5x5 heart image. Numbers go from 0 (off) to 9 (brightest). Note\nthe colon ':' to set the end of a row.",
    # "microbit.Image.width() \nReturn the width of the image in pixels.",
    # "microbit.Image.height() \nReturn the height of the image in pixels.",
    # "microbit.Image.get_pixel(x, y) \nUse get_pixel(x, y) to return the image's brightness at LED pixel (x,y).\nBrightness can be from 0 (LED is off) to 9 (maximum LED brightness).",
    # "microbit.Image.set_pixel(x, y, b) \nUse set_pixel(x, y, b) to set the LED pixel (x,y) in the image to brightness\n'b' which can be set between 0 (off) to 9 (full brightness).",
    # "microbit.Image.shift_left(n) \nUse shift_left(n) to make a copy of the image but moved 'n' pixels to the left.",
    # "microbit.Image.shift_right(n) \nUse shift_right(n) to make a copy of the image but moved 'n' pixels to\nthe right.",
    # "microbit.Image.shift_up(n) \nUse shift_up(n) to make a copy of the image but moved 'n' pixels up.",
    # "microbit.Image.shift_down(n) \nUse shift_down(n) to make a copy of the image but moved 'n' pixels down.",
    # "microbit.Image.copy() \nUse copy() to make a new exact copy of the image.",
    # "microbit.Image.crop(x1, y1, x2, y2) \nUse crop(x1, y1, x2, y2) to make a cut-out copy of the image where coordinate\n(x1,y1) is the top left corner of the cut-out area and coordinate (x2,y2) is the\nbottom right corner.",
    # "microbit.Image.invert() \nUse invert() to make a negative copy of the image. Where a pixel was bright or\non in the original, it is dim or off in the negative copy.",
    # "microbit.Image.HEART",
    # "microbit.Image.HEART_SMALL",
    # "microbit.Image.HAPPY",
    # "microbit.Image.SMILE",
    # "microbit.Image.SAD",
    # "microbit.Image.CONFUSED",
    # "microbit.Image.ANGRY",
    # "microbit.Image.ASLEEP",
    # "microbit.Image.SURPRISED",
    # "microbit.Image.SILLY",
    # "microbit.Image.FABULOUS",
    # "microbit.Image.MEH",
    # "microbit.Image.YES",
    # "microbit.Image.NO",
    # "microbit.Image.CLOCK12",
    # "microbit.Image.CLOCK11",
    # "microbit.Image.CLOCK10",
    # "microbit.Image.CLOCK9",
    # "microbit.Image.CLOCK8",
    # "microbit.Image.CLOCK7",
    # "microbit.Image.CLOCK6",
    # "microbit.Image.CLOCK5",
    # "microbit.Image.CLOCK4",
    # "microbit.Image.CLOCK3",
    # "microbit.Image.CLOCK2",
    # "microbit.Image.CLOCK1",
    # "microbit.Image.ARROW_N",
    # "microbit.Image.ARROW_NE",
    # "microbit.Image.ARROW_E",
    # "microbit.Image.ARROW_SE",
    # "microbit.Image.ARROW_S",
    # "microbit.Image.ARROW_SW",
    # "microbit.Image.ARROW_W",
    # "microbit.Image.ARROW_NW",
    # "microbit.Image.TRIANGLE",
    # "microbit.Image.TRIANGLE_LEFT",
    # "microbit.Image.CHESSBOARD",
    # "microbit.Image.DIAMOND",
    # "microbit.Image.DIAMOND_SMALL",
    # "microbit.Image.SQUARE",
    # "microbit.Image.SQUARE_SMALL",
    # "microbit.Image.RABBIT",
    # "microbit.Image.COW",
    # "microbit.Image.MUSIC_CROTCHET",
    # "microbit.Image.MUSIC_QUAVER",
    # "microbit.Image.MUSIC_QUAVERS",
    # "microbit.Image.PITCHFORK",
    # "microbit.Image.XMAS",
    # "microbit.Image.PACMAN",
    # "microbit.Image.TARGET",
    # "microbit.Image.TSHIRT",
    # "microbit.Image.ROLLERSKATE",
    # "microbit.Image.DUCK",
    # "microbit.Image.HOUSE",
    # "microbit.Image.TORTOISE",
    # "microbit.Image.BUTTERFLY",
    # "microbit.Image.STICKFIGURE",
    # "microbit.Image.GHOST",
    # "microbit.Image.SWORD",
    # "microbit.Image.GIRAFFE",
    # "microbit.Image.SKULL",
    # "microbit.Image.UMBRELLA",
    # "microbit.Image.SNAKE",
    # "microbit.Image.ALL_CLOCKS",
    # "microbit.Image.ALL_ARROWS",
    # # uart
    # "microbit.uart.init(baudrate=9600, bits=8, parity=None, stop=1, tx=None, rx=None) \nUse init() to set up communication using the default values. \nOtherwise override the defaults as named arguments.",
    # "microbit.uart.any() \nIf there are incoming characters waiting to be read, any() will return True.\nOtherwise, returns False.",
    # "microbit.uart.read(n) \nUse read() to read characters.\nUse read(n) to read, at most, 'n' bytes of data.",
    # "microbit.uart.readall() \nUse readall() to read as much data as possible.",
    # "microbit.uart.readline() \nUse readline() to read a line that ends with a newline character.",
    # "microbit.uart.readinto(buf, n) \nUse readinto(buf) to read bytes into the buffer 'buf'.\nUse readinto(buff, n) to read, at most, 'n' number of bytes into 'buf'.",
    # "microbit.uart.write() \nUse write(buf) to write the bytes in buffer 'buf' to the connected device.",
    # # SPI
    # "microbit.spi.init(baudrate=1000000, bits=8, mode=0, sclk=pin13, mosi=pin15, miso=pin14) \nSet up communication. Override the defaults for baudrate, mode,\nSCLK, MOSI and MISO. The default connections are pin13 for SCLK, pin15 for\nMOSI and pin14 for MISO.",
    # "microbit.spi.write(buf) \nUse write(buf) to write bytes in buffer 'buf' to the connected device.",
    # "microbit.spi.read(n) \nUse read(n) to read 'n' bytes of data.",
    # "microbit.spi.write_readinto(out, in) \nUse write_readinto(out, in) to write the 'out' buffer to the connected device\nand read any response into the 'in' buffer. The length of the buffers should\nbe the same. The buffers can be the same object.",
    # # Music module
    # "music.set_tempo(number, bpm) \nMake a beat last a 'number' of ticks long and\nplayed at 'bpm' beats per minute.",
    # "music.pitch(freq, length=-1, pin=microbit.pin0, wait=True) \nMake micro:bit play a note at 'freq' frequency for\n'length' milliseconds. E.g. pitch(440, 1000) will play concert 'A' for 1 second.\nIf length is a negative number the pitch is played continuously.\nUse the optional pin argument to override the default output for the speaker.\nIf wait is False the music will play in the background while the program\ncontinues.",
    # "music.play(music, pin=microbit.pin0, wait=True, loop=False) \nMake micro:bit play 'music' list of notes. Try out the built in music to see\nhow it works. E.g. music.play(music.PUNCHLINE).\nUse the optional pin argument to override the default output for the speaker.\nIf wait is False the music will play in the background while the program\ncontinues.\nIf loop is True, the tune will repeat.",
    # "music.get_tempo() \nReturn the number of ticks in a beat and number of beats per minute.",
    # "music.stop(pin=microbit.pin0) \nStops all music playback on the given pin. If no pin is given, pin0 is assumed.",
    # "music.reset()\nIf things go wrong, reset() the music to its default settings.",
    # "music.DADADADUM",
    # "music.ENTERTAINER",
    # "music.PRELUDE",
    # "music.ODE",
    # "music.NYAN",
    # "music.RINGTONE",
    # "music.FUNK",
    # "music.BLUES",
    # "music.BIRTHDAY",
    # "music.WEDDING",
    # "music.FUNERAL",
    # "music.PUNCHLINE",
    # "music.PYTHON",
    # "music.BADDY",
    # "music.CHASE",
    # "music.BA_DING",
    # "music.WAWAWAWAA",
    # "music.JUMP_UP",
    # "music.JUMP_DOWN",
    # "music.POWER_UP",
    # "music.POWER_DOWN",
    # # Antigravity
    # "antigravity",
    # # This module
    # "this.authors() \nUse authors() to reveal the names of the people who created this software.",
    # # Love module
    # "love.badaboom()\nHear my soul speak:\nThe very instant that I saw you, did\nMy heart fly to your service.",
    # # NeoPixel module
    # "neopixel.NeoPixel(pin, n) \nCreate a list representing a strip of 'n' neopixels controlled from the\nspecified pin (e.g. microbit.pin0).\nUse the resulting object to change each pixel by position (starting from 0).\nIndividual pixels are given RGB (red, green, blue) values between 0-255 as a\ntupe. For example, (255, 255, 255) is white:\n\nnp = neopixel.NeoPixel(microbit.pin0, 8)\nnp[0] = (255, 0, 128)\nnp.show()",
    # "neopixel.NeoPixel.clear() \nClear all the pixels.",
    # "neopixel.NeoPixel.show() \nShow the pixels. Must be called for any updates to become visible.",
    # RNG
    "random.getrandbits(n) \nReturn an integer with n random bits.",
    "random.seed(n) \nInitialise the random number generator with a known integer 'n'.",
    "random.randint(a, b) \nReturn a random whole number between a and b (inclusive).",
    "random.randrange(stop) \nReturn a random whole number between 0 and up to (but not including) stop.",
    "random.choice(seq) \nReturn a randomly selected element from a sequence of objects (such as a list).",
    "random.random() \nReturn a random floating point number between 0.0 and 1.0.",
    "random.uniform(a, b) \nReturn a random floating point number between a and b (inclusive).",
    # OS
    "os.listdir() \nReturn a list of the names of all the files contained within the local\non-device file system.",
    "os.remove(filename) \nRemove (delete) the file named filename.",
    "os.size(filename) \nReturn the size, in bytes, of the file named filename.",
    "os.uname() \nReturn information about MicroPython and the device.",
    # SYS
    "sys.version",
    "sys.version_info",
    "sys.implementation",
    "sys.platform",
    "sys.byteorder",
    "sys.print_exception(ex) \nPrint to the REPL information about the exception 'ex'.",
    # String functions
    "find(sub, start, end) \nReturn the lowest index in the string where substring 'sub' is found. The optional\n'start' and 'end' arguments specify the slice of string to use.\nReturns -1 if 'sub' cannot be found.",
    "rfind(sub, start, end) \nReturn the highest index in the string where substring 'sub' is found. The optional\n'start' and 'end' arguments specify the slice of string to use.\nReturns -1 if 'sub' cannot be found.",
    "index(sub, start, end) \nReturn the lowest index in the string where substring 'sub' is found. The optional\n'start' and 'end' arguments specify the slice of string to use.\nRaises a ValueError if 'sub' cannot be found.",
    "rindex(sub, start, end) \nReturn the highest index in the string where substring 'sub' is found. The optional\n'start' and 'end' arguments specify the slice of string to use.\nRaises a ValueError if 'sub' cannot be found.",
    "join(iterable) \nReturn a string which is the concatenation of the strings in 'iterable'.\nThe separator between elements is the string providing this method.",
    "split(sep=None, maxsplit=-1) \nReturn a list of the words in a string, using 'sep' as the delimiter string.\nIf 'sep' is not provided, the splitting algorithm uses whitespace.\nIf the optional 'maxsplit' is provided, splitting will occur 'maxsplit' times.",
    "rsplit(sep=None, maxsplit=-1) \nReturn a list of the words in a string, using 'sep' as the delimiter string.\nIf 'sep' is not provided, the splitting algorithm uses whitespace.\nIf the optional 'maxsplit' is provided, splitting will only occur 'maxsplit'\ntimes from the right.",
    "startswith(prefix) \nReturns True if the string starts with 'prefix'.",
    "endswith(suffix) \nReturns True if the string ends with 'suffix'.",
    "strip(chars) \nReturn a copy of the string with the leading and trailing characters removed.\nThe chars argument is a string specifying the set of characters to be removed.\nIf omitted or None, the chars argument defaults to removing whitespace.\nThe chars argument is not a prefix or suffix; rather, all combinations of its values are stripped",
    "lstrip(chars) \nReturn a copy of the string with leading characters removed. The chars argument\nis a string specifying the set of characters to be removed.\nIf omitted or None, the chars argument defaults to removing whitespace.\nThe chars argument is not a prefix; rather, all combinations of its values are\nstripped",
    "rstrip(chars) \nReturn a copy of the string with trailing characters removed. The chars argument\nis a string specifying the set of characters to be removed.\nIf omitted or None, the chars argument defaults to removing whitespace.\nThe chars argument is not a suffix; rather, all combinations of its values are\nstripped",
    "format(*args, **kwargs) \nPerform a string formatting operation. The string on which this method is called\ncan contain literal text or replacement fields delimited by braces {}. Each\nreplacement field contains either the numeric index of a positional argument,\nor the name of a keyword argument.\nReturns a copy of the string where each replacement field is replaced with the\nstring value of the corresponding argument.",
    "replace(old, new) \nReturn a copy of the string with all othe occurrences of 'old' replaced with 'new'.",
    "count(sub, start, end) \nReturn the number of non-overlapping occurrences of substring 'sub'.\nOptional arguments 'start' and 'end' specify the slice of the string to use. ",
    "partition(sep) \nSplit the string at the first occurrence of 'sep', and return a 3-tuple containing\nthe part before the separator, the separator itself, and the part after the separator.\nIf the separator is not found, return a 3-tuple containing the string itself,\nfollowed by two empty strings.",
    "rpartition(sep) \nSplit the string at the last occurrence of 'sep', and return a 3-tuple containing\nthe part before the separator, the separator itself, and the part after the separator.\nIf the separator is not found, return a 3-tuple containing two empty strings,\nfollowed by the string itself.",
    "lower() \nReturn a copy of the string with all the cased characters converted to lowercase.",
    "upper() \nReturn a copy of the string with all the cased characters converted to uppercase.",
    "isspace() \nReturn True if there are only whitespace characters in the string and thers is\nat least one character.",
    "isalpha() \nReturn True if all the characters in the string are alphabetic and there is\nat least one character.",
    "isdigit() \nReturn True if all characters in the string are digits and there is\nat least one character.",
    "isupper() \nReturn True if all characters in the string are uppercase and there is\nat least one character.",
    "islower() \nReturn True if all characters in the string are lowercase and there is\nat least one character.",
    # Math functions
    "math.sqrt(x) \nReturn the square root of 'x'.",
    "math.pow(x, y) \nReturn 'x' raised to the power 'y'.",
    "math.exp(x) \nReturn math.e**'x'.",
    "math.log(x, base=math.e) \nWith one argument, return the natural logarithm of 'x' (to base e).\nWith two arguments, return the logarithm of 'x' to the given 'base'.",
    "math.cos(x) \nReturn the cosine of 'x' radians.",
    "math.sin(x) \nReturn the sine of 'x' radians.",
    "math.tan(x) \nReturn the tangent of 'x' radians.",
    "math.acos(x) \nReturn the arc cosine of 'x', in radians.",
    "math.asin(x) \nReturn the arc sine of 'x', in radians.",
    "math.atan(x) \nReturn the arc tangent of 'x', in radians.",
    "math.atan2(x, y) \nReturn atan(y / x), in radians.",
    "math.ceil(x) \nReturn the ceiling of 'x', the smallest integer greater than or equal to 'x'.",
    "math.copysign(x, y) \nReturn a float with the magnitude (absolute value) of 'x' but the sign of 'y'. ",
    "math.fabs(x) \nReturn the absolute value of 'x'.",
    "math.floor(x) \nReturn the floor of 'x', the largest integer less than or equal to 'x'.",
    "math.fmod(x, y) \nReturn 'x' modulo 'y'.",
    "math.frexp(x) \nReturn the mantissa and exponent of 'x' as the pair (m, e). ",
    "math.ldexp(x, i) \nReturn 'x' * (2**'i').",
    "math.modf(x) \nReturn the fractional and integer parts of x.\nBoth results carry the sign of x and are floats.",
    "math.isfinite(x) \nReturn True if 'x' is neither an infinity nor a NaN, and False otherwise.",
    "math.isinf(x) \nReturn True if 'x' is a positive or negative infinity, and False otherwise.",
    "math.isnan(x) \nReturn True if 'x' is a NaN (not a number), and False otherwise.",
    "math.trunc(x) \nReturn the Real value 'x' truncated to an Integral (usually an integer).",
    "math.radians(x) \nConvert angle 'x' from degrees to radians.",
    "math.degrees(x) \nConvert angle 'x' from radians to degrees.",
    # built-in functions
    "abs(x) \nReturn the absolute value of the number 'x'.",
    "all(iterable) \nReturn True if all elements of iterable are true (or iterable is empty).",
    "any(iterable) \nReturn True if any element of iterable is true. If iterable is empty, return False.",
    "bin(x) \nConvert an integer (whole) number into a binary string.",
    "bool(x) \nReturn a Boolean value, i.e. one of True or False. The argument 'x' is used to\ngenerate the resulting truth value.",
    "bytearray(seq) \nReturn a new array of bytes specified by the sequence 'seq' of integers.",
    "bytes(seq) \nReturn a new 'bytes' object - an immutable sequence of 'seq' integers.",
    "callable(object) \nReturn True if the 'object' appears to be callable. Otherwise return False.",
    "chr(i) \nReturn a string representing a character whose Unicode code point is the integer 'i'.",
    "classmethod(function) \nReturn a class method for a function. Usually used as a decorator:\n\nclass C:\n  @classmethod\n  def func(cls): ...",
    "dict(): \nCreate a new dictionary object.",
    "dir(object) \nReturn a list of names in the scope of 'object'. If no object is supplied,\nreturns a ist of names in the current local scope.",
    "divmod(a, b) \nTake two (non complex) numbers and return a pair of numbers consisting of the quotient and remainder. For example, divmod(5, 4) results in (1, 1). That is, what's is 5 divided by 4? It's 1 remainder 1.",
    "enumerate(iterable, start=0) \nReturn an enumerate object from an iterable object.\nEach iteration of the resulting object returns a tuple containing a count and the value. For example:\n\nseasons = ['Spring', 'Summer', 'Autumn', 'Winter']\nlist(enumerate(seasons))\n[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]",
    "eval(expression, globals=None, locals=None) \nThe 'expression' string containing a Python expression is parsed and evaluated given\nthe context specified by 'globals' and 'locals' which must be dictionary objects.",
    "exec(object, globals, locals) \nThis function supports dynamic execution of Python code. The 'object' must be\na string containing Python code that can be parsed and evaluated. If `globals` and\n`locals` are emitted the code is executed in the local scope. Otherwise, both\n'globals' and 'locals' must be dictionary objects.",
    "filter(function, iterable) \nConstruct an iterator from those elements of 'iterable' for which 'function' returns True.",
    "float(x) \nReturn a floating point number constructed from a number or string 'x'.",
    "frozenset(iterable) \nReturn a new frozenset object, optionally with elements taken from 'iterable'.",
    "getattr(object, name, default) \nReturn the value fo the named attribute of 'object'. 'name' must be a string.\nOptionally return 'default' if 'name' is not an attribute of 'object'.",
    "globals() \nReturn a dictionary representing the current global symbol table.\nI.e. named objects that are currently in the global scope.",
    "hasattr(object, name) \nReturns True if the 'object' has an attribute called 'name'. 'name' must be a string.",
    "hash(object) \nReturn a hash value of the object (if it has one). Hash values are integers.",
    "help(object) \nInvoke the built-in help system (intended for interactive use in the REPL.",
    "hex(x) \nConvert an integer 'x' to a lowercase hexadevimal string prefixed with '0x'. For example, hex(255) returns '0xff'.",
    "id(object) \nReturn the identity of an object. This is an integer that is guaranteed to be unique.",
    "int(x, base=10) \nReturn an integer constructed from a number or string 'x'. The optional 'base' (indicating the base of the number) defaults to 10.",
    "isinstance(object, classinfo) \nReturn True if the 'object' is an instance of 'classinfo'.",
    "issubclass(class, classinfo) \nReturn True if the 'class' is a subclass (direct, indirect or virtual) of 'classinfo'.",
    "iter(object) \nReturn an iterator object for the 'object' (that must support the iteration protocol.",
    "len(object) \nReturn the length (the number of items) in an 'object'.",
    "list(iterable) \nReturn a list, optionally based upon the members of 'iterable'.",
    "locals() \nReturn a dictionary representing the current local symbol table. I.e. named objects\nthat are currently in the local scope.",
    "map(function, iterable) \nReturn an iterator that applies 'function' to every item of 'iterable', yielding the results.",
    "max(items) \nReturn the largest item in 'items', which can be either an iterable or two or more arguments.",
    "min(items) \nReturn the smallest item in 'items', which can be either an iterable or two or more arguments.",
    "next(iterator) \nRetrieve the next item from the iterator.",
    "object() \nReturn a new featureless object.",
    "oct(x) \nConvert an integer number to an octal (base 8) string.",
    "open(file, mode='rt') \nOpen 'file' and return a corresponding file object. The 'mode' is an optional\nstring that specifies how the file is opened:\n'r' - open for reading\n'w' - open for writing\n'b' - binary mode\n't' - text mode.",
    "ord(c) \nGiven a string representing one Unicode character, return an integer representing the Unicode code point of that character.",
    "pow(x, y, z) \nReturn 'x' to the power of 'y'. If the optional 'z' is given, return 'x' to the power of 'y' modulo 'z' (giving the remainder).",
    "print(*objects, sep=' ', end='\\n') \nPrint objects, separated by 'sep' and followed by 'end'. All non-keyword arguments are converted to strings.",
    "range(start, stop, step) \nReturn an immutable sequence containing items between 'start' and 'stop' with 'step' difference between them.",
    "repr(object) \nReturn a string containing a printable representation of an 'object'.",
    "reversed(seq) \nReturn a reverse iterator of the sequence 'seq'.",
    "round(number, ndigits) \nReturn the floating point 'number' rounded to the (optional) 'ndigits'.\nIf 'ndigits' is omitted, round to the nearest whole number.",
    "set(iterable) \nReturn a new set object, optionally containing elements taken from iterable.",
    "setattr(object, name, value) \nSet the 'value' to the attribute called 'name' on object 'object'. 'name' must be a string.",
    "sorted(iterable, key, reverse) \nReturn a new sorted list from the items in iterable. The optional 'key' specifies\na function used for comparison and the optional 'reverse' is a boolean indicating the comparison should be reversed.",
    "staticmethod(function) \nReturns a static method for a function. Usually used as a decorator:\n\nclass C:\n  @staticmethod\ndef func(): ...",
    "str(object) \nReturn a string version of 'object'.",
    "sum(iterable, start=0) \nSums 'start' and items of an iterable from left to right and returns the total.",
    "super(type, object-or-type) \nReturn a proxy object that delegates method calls to a parent or sibling class\nof 'type'. This is useful for accessing inherited methods that have been\noverridden in a class.",
    "tuple(iterable) \nReturn an immutable sequence based upon the items in 'iterable'.",
    "type(object) \nReturn the type of an object (i.e. what sort of thing it is).",
    "zip(*iterables) \nMake an iterator that aggregates elements from each of the passed in iterables.\nFor example:\nx = [1, 2, 3]\ny = [4, 5, 6]\nlist(zip(x, y))\n[(1, 4), (2, 5), (3, 6)]",
    # Radio
    # "radio.on() \nTurns on the radio. This needs to be called since the radio draws power and\ntakes up memory that you may otherwise need.",
    # "radio.off() \nTurns off the radio, thus saving power and memory.",
    # "radio.config(length=32, queue=3, channel=7, power=0, address=0x75626974, group=0, data_rate=radio.RATE_1MBIT) \nConfigures the various settings relating to the radio. The specified default\nvalues are sensible.\n'length' is the maximum length, in bytes, of a message. It can be up to 251\nbytes long.\n'queue' is the number of messages to store on the message queue.\n'channel' (0-100) defines the channel to which the radio is tuned.\n'address' is an arbitrary 32-bit address that's used to filter packets.\n'group' is an 8-bit value used with 'address' when filtering packets.\n'data_rate' is the throughput speed. It can be one of: radio.RATE_250KbIT,\nradio.RATE_1MbIT (the default) or radio.2MBIT.",
    # "radio.reset() \nReset the settings to their default value.",
    # "radio.send_bytes(message) \nSends a message containing bytes.",
    # "radio.receive_bytes() \nReceive the next incoming message from the message queue. Returns 'None' if\nthere are no pending messages. Messages are returned as bytes.",
    # "radio.send(message) \nSend a message string.",
    # "radio.receive() \nReceive the next incoming message from the message queue as a string. Returns\n'None' if there are no pending messages.",
    # "radio.RATE_250KBIT",
    # "radio.RATE_1MBIT",
    # "radio.RATE_2MBIT",
    # # Audio
    # "audio.play(source, wait=True, pins=(pin0, pin1)) \nPlay the source to completion where 'source' is an iterable, each element of\nwhich must be an AudioFrame instance.",
    # "audio.AudioFrame()() \nRepresents a list of 32 samples each of which is a signed byte. It takes just\nover 4ms to play a single frame.",
    # # Speech
    # "speech.translate(words) \nReturn a string containing the phonemes for the English words in the string\n'words'.",
    # "speech.say(words, pitch=64, speed=72, mouth=128, throat=128) \nSay the English words in the string 'words'. Override the optional pitch,\nspeed, mouth and throat settings to change the tone of voice.",
    # "speech.pronounce(phonemes, pitch=64, speed=72, mouth=128, throat=128) \nPronounce the phonemes in the string 'phonemes'. Override the optional pitch,\nspeed, mouth and throat settings to change the tone of voice.",
    # "speech.sing(song, pitch=64, speed=72, mouth=128, throat=128) \nSing the phonemes in the string 'song'. Add pitch information to a phoneme\nwith a hash followed by a number between 1-255 like this: '#112DOWWWWWWWW'.\nOverride the optional pitch, speed, mouth and throat settings to change the\ntone of voice.",
]

SUPPORTED_APIS = MICROPYTHON_APIS + TBSENSE_APIS
